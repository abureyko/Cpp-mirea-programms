#include <iostream>
using namespace std; 

int main(){
    int n, k;
    cin >> n >> k;
    while (k != 1){
        n = (n-k%2) / 2;
        k /= 2; 
    }

    cout << (n-1) / 2 << endl << n / 2 << endl;

    return 0;
}

// Данный алгоритм решает задачу через моделирование бинарного процесса выбора мест. 
// Вместо последовательной обработки каждого школьника, что было бы неэффективно для больших значений, программа использует математический подход.
// На каждом шаге цикла определяется, в какую половину текущего свободного промежутка попадает последний школьник. 
// Четность значения K показывает, выбираем ли мы левую или правую ветвь в дереве решений. 
// Операции деления N и K пополам позволяют быстро "проскакать" через все промежуточные состояния.
// После завершения цикла мы получаем параметры отрезка, куда сядет последний школьник. 
// Финальные вычисления определяют размеры оставшихся свободных пространств по обе стороны от него.

// Пример работы при n = 7, k = 3
// Шаг 1: n = 7, k = 3
// while (3 != 1) - выполняем
// n = (7 - 3%2) / 2 = (7 - 1) / 2 = 3
// k = 3 / 2 = 1

// Шаг 2: n = 3, k = 1
// while (1 != 1) - выходим из цикла

// Вывод: (3-1)/2 = 1 и 3/2 = 1
// Ответ: 1 1